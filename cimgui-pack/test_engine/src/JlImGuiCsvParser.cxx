// this file was auto-generated by wrapit v1.3.3
#include "Wrapper.h"

#include "jlImGuiTestEngine.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<ImGuiCsvParser> : std::false_type { };
  template<> struct DefaultConstructible<ImGuiCsvParser> : std::false_type { };
}

// Class generating the wrapper for type ImGuiCsvParser
// signature to use in the veto file: ImGuiCsvParser
struct JlImGuiCsvParser: public Wrapper {

  JlImGuiCsvParser(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type ImGuiCsvParser (" __HERE__ ")");
    // defined in ./imgui_test_engine/imgui_test_engine/imgui_te_utils.h:158:8
    jlcxx::TypeWrapper<ImGuiCsvParser>  t = jlModule.add_type<ImGuiCsvParser>("ImGuiCsvParser");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<ImGuiCsvParser>>(new jlcxx::TypeWrapper<ImGuiCsvParser>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void ImGuiCsvParser::ImGuiCsvParser(int) (" __HERE__ ")");
    // defined in ./imgui_test_engine/imgui_test_engine/imgui_te_utils.h:169:5
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool ImGuiCsvParser::Load(const char *) (" __HERE__ ")");
    // signature to use in the veto list: bool ImGuiCsvParser::Load(const char *)
    // defined in ./imgui_test_engine/imgui_test_engine/imgui_te_utils.h:171:21
    t.method("Load", static_cast<bool (ImGuiCsvParser::*)(const char *) >(&ImGuiCsvParser::Load));

    DEBUG_MSG("Adding wrapper for void ImGuiCsvParser::Clear() (" __HERE__ ")");
    // signature to use in the veto list: void ImGuiCsvParser::Clear()
    // defined in ./imgui_test_engine/imgui_test_engine/imgui_te_utils.h:172:21
    t.method("Clear", static_cast<void (ImGuiCsvParser::*)() >(&ImGuiCsvParser::Clear));

    DEBUG_MSG("Adding wrapper for const char * ImGuiCsvParser::GetCell(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const char * ImGuiCsvParser::GetCell(int, int)
    // defined in ./imgui_test_engine/imgui_test_engine/imgui_te_utils.h:173:21
    t.method("GetCell", [](ImGuiCsvParser& a, int arg0, int arg1) { return (std::string)a.GetCell(arg0, arg1); });
    t.method("GetCell", [](ImGuiCsvParser* a, int arg0, int arg1) { return (std::string)a->GetCell(arg0, arg1); });

    DEBUG_MSG("Adding Columns methods  to provide read access to the field Columns (" __HERE__ ")");
    // defined in ./imgui_test_engine/imgui_test_engine/imgui_te_utils.h:161:21
    // signature to use in the veto list: ImGuiCsvParser::Columns
    t.method("Columns", [](const ImGuiCsvParser& a) -> int { return a.Columns; });
    t.method("Columns", [](ImGuiCsvParser& a) -> int { return a.Columns; });
    t.method("Columns", [](const ImGuiCsvParser* a) -> int { return a->Columns; });
    t.method("Columns", [](ImGuiCsvParser* a) -> int { return a->Columns; });
    // defined in ./imgui_test_engine/imgui_test_engine/imgui_te_utils.h:161:21
    // signature to use in the veto list: ImGuiCsvParser::Columns
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Columns! methods to provide write access to the field Columns (" __HERE__ ")");
    t.method("Columns!", [](ImGuiCsvParser& a, int val) -> int { return a.Columns = val; });

    DEBUG_MSG("Adding Columns! methods to provide write access to the field Columns (" __HERE__ ")");
    t.method("Columns!", [](ImGuiCsvParser* a, int val) -> int { return a->Columns = val; });

    DEBUG_MSG("Adding Rows methods  to provide read access to the field Rows (" __HERE__ ")");
    // defined in ./imgui_test_engine/imgui_test_engine/imgui_te_utils.h:162:21
    // signature to use in the veto list: ImGuiCsvParser::Rows
    t.method("Rows", [](const ImGuiCsvParser& a) -> int { return a.Rows; });
    t.method("Rows", [](ImGuiCsvParser& a) -> int { return a.Rows; });
    t.method("Rows", [](const ImGuiCsvParser* a) -> int { return a->Rows; });
    t.method("Rows", [](ImGuiCsvParser* a) -> int { return a->Rows; });
    // defined in ./imgui_test_engine/imgui_test_engine/imgui_te_utils.h:162:21
    // signature to use in the veto list: ImGuiCsvParser::Rows
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Rows! methods to provide write access to the field Rows (" __HERE__ ")");
    t.method("Rows!", [](ImGuiCsvParser& a, int val) -> int { return a.Rows = val; });

    DEBUG_MSG("Adding Rows! methods to provide write access to the field Rows (" __HERE__ ")");
    t.method("Rows!", [](ImGuiCsvParser* a, int val) -> int { return a->Rows = val; });

    DEBUG_MSG("Adding _Data methods  to provide read access to the field _Data (" __HERE__ ")");
    // defined in ./imgui_test_engine/imgui_test_engine/imgui_te_utils.h:165:21
    // signature to use in the veto list: ImGuiCsvParser::_Data
    t.method("_Data", [](const ImGuiCsvParser& a) -> char * { return a._Data; });
    t.method("_Data", [](ImGuiCsvParser& a) -> char * { return a._Data; });
    t.method("_Data", [](const ImGuiCsvParser* a) -> char * { return a->_Data; });
    t.method("_Data", [](ImGuiCsvParser* a) -> char * { return a->_Data; });
    // defined in ./imgui_test_engine/imgui_test_engine/imgui_te_utils.h:165:21
    // signature to use in the veto list: ImGuiCsvParser::_Data
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding _Data! methods to provide write access to the field _Data (" __HERE__ ")");
    t.method("_Data!", [](ImGuiCsvParser& a, char * val) -> char * { return a._Data = val; });

    DEBUG_MSG("Adding _Data! methods to provide write access to the field _Data (" __HERE__ ")");
    t.method("_Data!", [](ImGuiCsvParser* a, char * val) -> char * { return a->_Data = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<ImGuiCsvParser>> type_;
};
std::shared_ptr<Wrapper> newJlImGuiCsvParser(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlImGuiCsvParser(module));
}
